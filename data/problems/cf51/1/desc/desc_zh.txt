# 题面
斯大林排序是一种幽默的排序算法，旨在消除不合适的元素，而不是费心地对它们进行正确排序，其时间复杂度为 $\mathcal{O}(n)$ 。

算法如下：从数组中的第二个元素开始，如果它严格小于前一个元素（忽略那些已经被删除的元素），那么就删除它。继续迭代数组，直到按非递减顺序排序。例如，经过斯大林排序后，数组 $[1, 4, 2, 3, 6, 5, 5, 7, 7]$ 变成了 $[1, 4, 6, 7, 7]$ 。

我们将一个数组定义为脆弱数组，如果你可以通过对数组中的任意一个子数组 $^{\text{∗}}$ **重复应用斯大林排序，并按**非递增**顺序对其进行排序，次数不限。

给定一个由 $n$ 个整数组成的数组 $a$ ，请确定从该数组中删除的整数的最小数目，以使该数组变得脆弱。

$^{\text{∗}}$ 如果数组 $a$ 可以从 $b$ 中删除开头的几个（可能是零个或全部）元素和结尾的几个（可能是零个或全部）元素，那么 $a$ 就是数组 $b$ 的子数组。

solution的主函数如下：  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
其中：  
- 返回值为使数组脆弱的最小整数数目

# 示例 1：  
- 输入：  
n = 7
a = [3, 6, 4, 9, 2, 5, 2]
- 输出：  
2

# 约束条件：  
- $1 \leq n \leq 10000$
- $1 \leq a[i] \leq 10^9$ 
- 时间限制：1000 ms  
- 内存限制：640 KB  