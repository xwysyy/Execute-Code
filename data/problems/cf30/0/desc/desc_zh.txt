# 题面
给你一个二进制表示的数字，它正好由 $n$ 位组成，可能还有前导零。例如，对于 $n = 5$ ，数字 $6$ 将表示为 $00110$ ；对于 $n = 4$ ，数字 $9$ 将表示为 $1001$ 。

我们来确定一个整数 $i$ ，即 $1 \le i \le n$ 。只需一次操作，就可以交换二进制表示中任意两个相邻的位。你的目标是找出要使这个数能被 $2^i$ 整除所需的最小运算次数，或者说这个数是不可能被 $2^i$ 整除的。

请注意，对于每个 $1 \le i \le n$ 你都要独立解题，答案可能会很大，使用 $64$ 位整数类型。

solution的主函数如下：  
```cpp
class Solution {
public:
    vector<long long> solve(int &n, string &s) {   
        // write your code here
    }
};
```
其中：  
- `n` 表示数字的位数
- `s` 表示二进制表示的数字
- 返回一个数组，数组的第 $i$ 个元素表示使数字能被 $2^i$ 整除所需的最小运算次数

# 示例 1：  
- 输入：  
n = 2
s = "01"
- 输出：  
[1, -1]

# 约束条件：  
- $1 \leq n \leq 100000$  
- 时间限制：1000 ms  
- 内存限制：6400 KB  