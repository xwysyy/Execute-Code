# 题面
樱子的考试结束了，她的成绩非常优秀。作为奖励，她得到了一个变式 $p$ 。幸介并不完全满意，因为他有一次考试没及格，也没有收到礼物。他决定潜入她的房间（多亏了她门锁上的密码），破坏这个排列组合，让它变得简单。

如果每 $i$ 个 $(1\le i \le n)$ 中有一个 $p$ 被认为是简单排列，那么这个排列 $p$ 就是简单排列。 $(1\le i \le n)$ 中，有一个条件成立，那么这个排列 $p$ 就被认为是简单排列：

- $p_i=i$
- $p_{p_i}=i$

例如，排列组合 $[1, 2, 3, 4]$ 、 $[5, 2, 4, 3, 1]$ 和 $[2, 1]$ 是简单的，而 $[2, 3, 1]$ 和 $[5, 2, 1, 4, 3]$ 不是。

在一次操作中，浩介可以选择索引 $i,j$ 和 $(1\le i,j\le n)$ 。 $(1\le i,j\le n)$ 并交换元素 $p_i$ 和 $p_j$ 。

樱子即将回家。你的任务是计算小幸最少需要进行多少次操作才能使排列变得简单。

solution的主函数如下：  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &p) {   
        // write your code here
    }
};
```
其中：  
- 返回值为使得排列变得简单所需的最少操作次数

# 示例 1：  
- 输入：  
n = 5
p = [1, 2, 3, 4, 5]
- 输出：  
0

# 约束条件：  
- $1 \leq n \leq 1000000$
- $1 \leq p[i] \leq n$ 
- 时间限制：1000 ms  
- 内存限制：256 KB  