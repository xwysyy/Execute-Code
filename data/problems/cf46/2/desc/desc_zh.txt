# 题面
有一个由 $2$ 行和 $n$ 列组成的网格。网格中的每个单元格要么是空闲的，要么是受阻的。

如果至少有一个条件成立，则可以从自由单元格 $x$ 到达自由单元格 $y$ ：

- $x$ 和 $y$ 共享一条边；
- 存在一个自由单元 $z$ ，使得 $z$ 可以从 $x$ 到达，并且 $y$ 可以从 $z$ 到达。

连通区域是网格中自由单元格的集合，其中的所有单元格都可以相互连通，但在该集合中添加任何其他自由单元格都会违反这一规则。

给定网格中最多包含 $1$ 个相连区域。您的任务是计算满足以下约束条件的空闲单元格的数量：

- 如果该单元格被阻塞，则连接区域的数量正好变为 $3$ 。

solution的主函数如下：  
```cpp
class Solution {
public:
    int solve(int &n, string &s1, string &s2) { 
        // write your code here
    }
};
```
其中：  
- `s1`和`s2`是两行字符串，表示网格的两行, 每个字符是`.`或`x`，`.`表示空闲，`x`表示受阻
- 返回值是满足条件的空闲单元格的最大值

# 示例 1：  
- 输入：  
n = 8
s1 = ".......x"
s2 = ".x.xx..."
- 输出：  
1

# 约束条件：  
- $1 \leq n \leq 1000000$
- 给定网格中最多包含 $1$ 个相连区域
- 时间限制：1000 ms  
- 内存限制：64 KB  